This patch has been added to use double _Complex as the return type of
zdotu_ to work around errors in assuming direct convertibility to
std::complex<double> of the zdotu_ function's return value.

Kumar Appaiah <akumar@ee.iitm.ac.in>
Index: b/configure
===================================================================
--- a/configure
+++ b/configure
@@ -26594,7 +26594,7 @@
 #include <complex>
 typedef std::complex<double> cdouble;
 extern "C" {
-  cdouble zdotu_(const int *, const cdouble *, const int *,
+  double _Complex zdotu_(const int *, const cdouble *, const int *,
                  const cdouble *, const int *);
 }
 int main() {
@@ -26607,7 +26607,7 @@
                      cdouble(-0.6094,-0.2975), cdouble( 0.2106,-0.2026),
                      cdouble( 0.1043,-0.8300), cdouble( 0.0806, 0.3698)};
   cdouble x_ref(-2.01767031,-0.45861365);
-  cdouble x = zdotu_(&size, a, &incr, b, &incr);
+  cdouble x = std::complex<double>(zdotu_(&size, a, &incr, b, &incr));
   return (std::abs(x - x_ref) < 1e-6) ? 0 : 1;
 }
 _ACEOF
Index: b/itpp/base/blas.h
===================================================================
--- a/itpp/base/blas.h
+++ b/itpp/base/blas.h
@@ -94,7 +94,7 @@
               const std::complex<double> *x, const int *incx,
               const std::complex<double> *y, const int *incy);
 #elif defined(HAVE_ZDOTU_RETURN)
-  std::complex<double> zdotu_(const int *n,
+  double _Complex zdotu_(const int *n,
                               const std::complex<double> *x, const int *incx,
                               const std::complex<double> *y, const int *incy);
 #else
Index: b/itpp/base/vec.h
===================================================================
--- a/itpp/base/vec.h
+++ b/itpp/base/vec.h
@@ -928,7 +928,7 @@
 #if defined(HAVE_ZDOTU_VOID)
     blas::zdotu_(&output, &v1.datasize, v1.data, &incr, v2.data, &incr);
 #elif defined(HAVE_ZDOTU_RETURN)
-    output = blas::zdotu_(&v1.datasize, v1.data, &incr, v2.data, &incr);
+    output = std::complex<double>(blas::zdotu_(&v1.datasize, v1.data, &incr, v2.data, &incr));
 #else
     blas::zdotusub_(&output, &v1.datasize, v1.data, &incr, v2.data, &incr);
 #endif // HAVE_ZDOTU_VOID
